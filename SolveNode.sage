p = 4368590184733545720227961182704359358435747188309319510520316493183539079703
fp = GF(p)

x1 = fp(2582928974243465355371953056699793745022552378548418288211138499777818633265)
y1 = fp(2421683573446497972507172385881793260176370025964652384676141384239699096612)
x2 = fp(8742397231329873984594235438374590234800923467289367269837473862487362482)
y2 = fp(225987949353410341392975247044711665782695329311463646299187580326445253608)

R.<a,b> = PolynomialRing(fp)
f = y1^2 - (x1^3 + a*x1 + b)
g = y2^2 - (x2^3 + a*x2 + b)
print(f)
print(g)

I = ideal(f, g)
B = I.groebner_basis()
print(B[0])
print(-B[0])
print(-B[1])
R.<x>=PolynomialRing(fp)
a=64186688762130075872648727143532923412208390610536286437268423112
b=32579945572763798990069104934898692239152360555014084068553395172709029894
u=-x^3-a*x-b
print(u.roots())
singular = vector([fp(1557923326969252180825193218688702224840389936248863823173183835359957757721),fp(0)])
# E = EllipticCurve(fp, [a, b])
R.<x>=PolynomialRing(fp)
f = x^3 + a*x + b
f_ = f.subs(x+singular[0])
print(f_)

Q = vector([x1, y1])-(singular)
P = vector([x2, y2])-(singular)
k=fp(305179796174210822247618473361747316085422620437271958999235012896334193460)
t = k.square_root()
# Q=dP->fq=(fp)^d (node) 掛け算のDLP F^*
# Q=dP -> q = dp (cusp) 足し算のDLP F^+
Px, Py = P
Qx, Qy = Q
p = (Py + t*Px) / (Py - t*Px)
q = (Qy + t*Qx) / (Qy - t*Qx)

d = q.log(p)
#d = p.log(q)
#d = q.log(p)
print(d)
from Crypto.Util.number import *
print(long_to_bytes(int(d)))